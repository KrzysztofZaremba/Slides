layout(scene = list(aspectmode = "cube"))
set.seed(123)
# Number of observations
n <- 100
# Generate random values for x1 and x2
x1 <- rnorm(n)
x2 <- rnorm(n)
# Generate random errors
u <- rnorm(n)
# Calculate y using the model equation
y <- 5 + 2 * x1 + x2 + u
# Create a data frame with the variables
data <- data.frame(x1, x2, y)
# Load the necessary packages for 3D plotting
library(plotly)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = data)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(data$x1), max(data$x1), length.out = 20)
x2_grid <- seq(min(data$x2), max(data$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Load the necessary packages for 3D plotting
library(plotly)
# Create an interactive 3D scatter plot with the regression plane
plot_ly(data, x = ~x1, y = ~x2, z = ~y, type = "scatter3d", mode = "markers") %>%
add_trace(data = grid_data, x = ~x1, y = ~x2, z = ~y_pred, type = "surface") %>%
layout(scene = list(aspectmode = "cube"))
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = data)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(data$x1), max(data$x1), length.out = 20)
x2_grid <- seq(min(data$x2), max(data$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Load the necessary packages for 3D plotting
library(rgl)
# Create a 3D scatter plot of the original data
plot3d(data$x1, data$x2, data$y, col = "blue", type = "s", size = 2)
library(gdl)
install.packages("rgl")
# Load the necessary packages for 3D plotting
library(rgl)
# Create a 3D scatter plot of the original data
plot3d(data$x1, data$x2, data$y, col = "blue", type = "s", size = 2)
# Add the regression plane
planes3d(lm_model$coefficients[1], lm_model$coefficients[2], lm_model$coefficients[3], lm_model$coefficients[4], col = "red", alpha = 0.5)
# Add the regression plane
planes3d(lm_model$coefficients[1], lm_model$coefficients[2], lm_model$coefficients[3], lm_model$coefficients[4], col = "red", alpha = 0.5)
library(plotly)
library(reshape2)
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ 0 + x1 + x2, data = my_df)
# Graph Resolution (more important for more complex shapes)
graph_reso <- 0.05
# Setup Axis
axis_x <- seq(min(my_df$x1), max(my_df$x1), by = graph_reso)
axis_y <- seq(min(my_df$x2), max(my_df$x2), by = graph_reso)
# Sample points
lm_surface_data <- expand.grid(x1 = axis_x, x2 = axis_y, KEEP.OUT.ATTRS = FALSE)
lm_surface_data$y_pred <- predict(lm_model, newdata = lm_surface_data)
lm_surface_data <- acast(lm_surface_data, x2 ~ x1, value.var = "y_pred") # x2 ~ x1
# Create the base graph (the points), adding color and text for each species
hcolors <- "blue"  # You can choose your color here
my_df$Species <- "Simulated Data"
lm_plot <- plot_ly(my_df,
x = ~x1,
y = ~x2,
z = ~y,
text = ~Species,
type = "scatter3d",
mode = "markers",
marker = list(color = hcolors))
# Add the surface
lm_plot <- add_trace(lm_plot,
z = lm_surface_data,
x = axis_x,
y = axis_y,
type = "surface")
lm_plot
lm_surface_data
acast(lm_surface_data, x2 ~ x1, value.var = "y_pred") # x2 ~ x1
lm_surface_data$y_pred <- predict(lm_model, newdata = lm_surface_data)
lm_surface_data <- acast(lm_surface_data, x2 ~ x1, value.var = "y_pred") # x2 ~ x1
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ 0 + x1 + x2, data = my_df)
# Graph Resolution (more important for more complex shapes)
graph_reso <- 0.05
# Setup Axis
axis_x <- seq(min(my_df$x1), max(my_df$x1), by = graph_reso)
axis_y <- seq(min(my_df$x2), max(my_df$x2), by = graph_reso)
# Sample points
lm_surface_data <- expand.grid(x1 = axis_x, x2 = axis_y, KEEP.OUT.ATTRS = FALSE)
lm_surface_data$y_pred <- predict(lm_model, newdata = lm_surface_data)
lm_surface_data <- acast(lm_surface_data, x2 ~ x1, value.var = "y_pred") # x2 ~ x1
# Create the base graph (the points), adding color and text for each species
hcolors <- "blue"  # You can choose your color here
my_df$Species <- "Simulated Data"
lm_plot <- plot_ly(my_df,
x = ~x1,
y = ~x2,
z = ~y,
text = ~Species,
type = "scatter3d",
mode = "markers",
marker = list(color = hcolors))
# Add the surface
lm_plot <- add_trace(lm_plot,
z = lm_surface_data,
x = axis_x,
y = axis_y,
type = "surface")
lm_plot
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y, text = ~Species, type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y, text = ~Species, type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
xaringan::inf_mr()
xaringan::inf_mr()
xaringan::inf_mr()
xaringan::inf_mr()
xaringan::inf_mr()
xaringan::inf_mr()
library(plotly)
library(reshape2)
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y, text = ~Species, type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)%>%
layout(height = 100)
library(plotly)
library(reshape2)
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)%>%
layout(height = 100)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)%>%
layout(height = 100)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers",height = 100) %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
library(plotly)
library(reshape2)
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers",height = 100) %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
library(plotly)
library(reshape2)
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers",height = 100) %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
xaringan::inf_mr()
library(plotly)
library(reshape2)
# Simulate your data
set.seed(123)
n <- 100
x1 <- rnorm(n)
x2 <- rnorm(n)
u <- rnorm(n)
y <- 5 + 2 * x1 + x2 + u
my_df <- data.frame(x1 = x1, x2 = x2, y = y)
# Fit a multiple linear regression model
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers",height = 100) %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
# Load the necessary packages for 3D plotting
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y, text = ~Species, type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
set.seed(123)
# Number of observations
n <- 100
# Generate random values for x1 and x2
x1 <- rnorm(n)
x2 <- rnorm(n)
# Generate random errors
u <- rnorm(n)
# Calculate y using the model equation
y <- 5 + 2 * x1 + x2 + u
# Create a data frame with the variables
data <- data.frame(x1, x2, y)
# Load the necessary packages for 3D plotting
lm_model <- lm(y ~ x1 + x2, data = my_df)
# Create a grid of values for x1 and x2
x1_grid <- seq(min(my_df$x1), max(my_df$x1), length.out = 20)
x2_grid <- seq(min(my_df$x2), max(my_df$x2), length.out = 20)
grid_data <- expand.grid(x1 = x1_grid, x2 = x2_grid)
# Predict y values using the regression model
grid_data$y_pred <- predict(lm_model, newdata = grid_data)
# Convert the grid data to a matrix for persp plot
z_matrix <- matrix(grid_data$y_pred, nrow = length(x1_grid), ncol = length(x2_grid), byrow = TRUE)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers") %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
# Create the base 3D scatter plot (points)
plot_ly(my_df, x = ~x1, y = ~x2, z = ~y,  type = "scatter3d", mode = "markers", height=200) %>%
layout(scene = list(aspectmode = "cube")) %>%
# Add the surface using persp
add_surface(z = ~z_matrix, x = x1_grid, y = x2_grid, opacity = 0.6)
xaringan::inf_mr()
knitr::opts_chunk$set(echo = TRUE,dpi=300)
library(shiny)
library(ggplot2)
library(forecast)
library(plotly)
library(dplyr)
library(igraph)
library(reshape)
library(spData)
library(leaflet)
library(readr)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(hrbrthemes)
library(gridExtra)
library(cowplot)
library(viridis)
library(gapminder)
library(knitr)
library(kableExtra)
library(DT)
x1_grid
x2_grid
expand.grid(x1 = x1_grid, x2 = x2_grid)
expand.grid(x1 = x1_grid, x2 = x2_grid)
xaringan::inf_mr()
X <- matrix(c(4, 18, 27, 18, 66, 89, 27, 89, 134), nrow = 3, byrow = TRUE)
# Calculate the inverse
X_inverse <- solve(X)
# Print the result
print(X_inverse)
xaringan::inf_mr()
X <- matrix(c(1, 3, 8, 1, 4, 7, 1, 6, 6, 1, 5, 7), nrow = 4, byrow = TRUE)
beta <- c(85.19, 5.36, 0.21)
# Perform the multiplication
predicted_values <- X %*% beta
# Display the result as a vector
predicted_values
A <- matrix(c(1, 1, 1, 1, 3, 4, 6, 5, 8, 7, 6, 7), nrow = 3, byrow = TRUE)
B <- c(80, 85, 92, 88)
# Perform the multiplication
result <- A %*% B
result
A
inverse_XtX <- matrix(c(-0.69, 0.0067, 0.135, 0.006, 0.145, -0.097, 0.135, -0.09, 0.045), nrow = 3, byrow = TRUE)
# Define the vector
vector_Y <- c(345, 1572, 2403)
# Perform the multiplication
result <- inverse_XtX %*% vector_Y
# Display the result as a vector
result
X=matrix(c(1, 3, 8, 1, 4, 7, 1, 6, 6, 1, 5, 7), nrow = 4, byrow = TRUE)
View(X)
View(X)
y=c(80,85,92,88)
y
X*X
t(X)*X
t(X)%*%X
inv(t(X)%*%X)
solve(t(X)%*%X)
inv(t(X)%*%X)
solve(t(X)%*%X)
solve(t(X)%*%X)%*%t(X)%*%y
b=solve(t(X)%*%X)%*%t(X)%*%y
X%*%b
install.packages("GGally")
xaringan::inf_mr()
knitr::opts_chunk$set(echo = TRUE,dpi=300)
library(shiny)
library(ggplot2)
library(forecast)
library(plotly)
library(dplyr)
library(igraph)
library(reshape)
library(spData)
library(leaflet)
library(readr)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(hrbrthemes)
library(gridExtra)
library(cowplot)
library(viridis)
library(gapminder)
library(knitr)
library(kableExtra)
library(DT)
workers <- 100  # Number of workers
WorkMode <- factor(sample(c("Fully at the office", "Fully remote", "Hybrid"),
workers, replace = TRUE),
levels = c("Fully at the office", "Fully remote", "Hybrid"))
Productivity <- round(runif(workers, 70, 130))  # Random productivity scores between 70 and 130
WorkerID=1:100
data.frame(WorkerID, WorkerMode,Productivity)
data.frame(WorkerID, WorkMode,Productivity)
ddata.frame(WorkerID, WorkMode,Productivity)
d=data.frame(WorkerID, WorkMode,Productivity)
round(runif(workers, 500000, 100000))
round(runif(workers, 50000, 100000))
xaringan::inf_mr()
0.206-1.96*0.067
0.206+1.96*0.067
xaringan::inf_mr()
knitr::opts_chunk$set(echo = TRUE,dpi=300)
library(shiny)
library(ggplot2)
library(forecast)
library(plotly)
library(dplyr)
library(igraph)
library(reshape)
library(spData)
library(leaflet)
library(readr)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(hrbrthemes)
library(gridExtra)
library(cowplot)
library(viridis)
library(gapminder)
library(knitr)
library(kableExtra)
library(DT)
# Fit a linear regression model
lm_model <- lm(Duration ~ Occupancy+EDAD, data = Sample_urg)
# Display the summary of the linear regression model
summary(lm_model)
model.matrix(lm_model)
X=model.matrix(lm_model)
X
t(X)%*%X
solve(t(X)%*%X)
x=c(1, 10, 52)
x%*%solve(t(X)%*%X)%*%t(x)
x%*%solve(t(X)%*%X)%*%x
t(x)%*%solve(t(X)%*%X)%*%x
sqrt(0.0004376598)
sum(lm_model$residuals)
lm_model$residuals
sum(lm_model$residuals^2)
sum(lm_model$residuals^2)/4997
\sqrt(sum(lm_model$residuals^2)/4997)
sqrt(sum(lm_model$residuals^2)/4997)
23.236*1+3.7*10+0.2*52
98.97*0.021
1.96*2.07837
70.636-4.073605
70.636+4.073605
lm_model <- lm(Duration ~ Occupancy+EDAD, data = Sample_urg)
new_data<- data.frame(Occupancy= c(30), EDAD=52)
predict(lm_model, newdata = new_data, interval = "predict", level = 0.95, se.fit=TRUE)
new_data<- data.frame(Occupancy= c(10), EDAD=52)
predict(lm_model, newdata = new_data, interval = "predict", level = 0.95, se.fit=TRUE)
predict(lm_model, newdata = new_data, interval = "confidence", level = 0.95, se.fit=TRUE)
